Hello and welcome to week five. This week we're going to be looking at the networking and security side of Cloud. So how does networking work in the Cloud and then some kind of the things for security considerations that we have around, specifically around Cloud networking, but also a few other things. So here's the overview. We'll start off with thinking about how we can, what are the principles that we can use for designing our applications to be secure in the Cloud. So thinking about the Cloud architecture from a security point of view. Jix is going to do some stuff on about Cloud networking, around virtual private clouds and subnets, and then we'll talk about security groups and network access control lists, proxies and web application firewalls, and we'll finish up with a little bit on secrets management. So first of all, let's think about security from a design point of view. So when we're designing an application or other kind of environment in the computing environment in the Cloud, what are the kind of ways that we can think about that from a security point of view. So make sure that we can actually implement security into that environment. So I'm going to use the idea of first-class security. So just like how we have, you may have heard of first-class functions, and in the context of functional programming. So the idea is that we want to treat security as we would any other type of application requirement. So usually we very often think about functionality. When you're thinking about applications, but we really should be thinking about other aspects of our application and security as one of them. So we want to think of security in the same way as we think of functionality as a high priority item that needs to be designed in. And so the reason why here is because like, when you have security failures, they can be the make headlines, right? And that can be much worse than something just going down for the wall. So we have to make sure that we're taking that to account. Loss of functionality is one thing. Loss of security is another thing. And often the loss of the security is actually worse. So we're going to find that what we're going to do is talk about a bunch of security principles here. And you'll come across these in many different contexts when it comes to security. There's our kind of general ideas that don't necessarily apply only to cloud, but we're going to try to put them into the cloud context. So especially if you're taking cap 4 for 1, you will be seeing these again, but you will have already seen them. But we're going to look at them again in the light of the cloud environment. So first of all, understanding entities and roles. So in this context, when you're thinking about designing a application in the cloud, entities is going to be things like your users. And then also things that are in the cloud that can take action. So things like computing resources, network resources, data services, like databases and things like that. And those are things that you're going to read objects that you've got. And that's talked to each other, communicate with each other, take actions. And they have things that they do. So those are the roles. So we have to think about who is it that needs to do what? So for example, a user has certain things that needs to be able to do. Contacting the database directly is probably not one of them. So we have to define what is the things that each entity needs to be able to do. And there's also different ways that you can do this. And this is where the design comes into it. Because you can think of different ways of packaging up different tasks that need to be done. So that sometimes you have an entity that you might have an entity that has a certain allocation of things that it could do. But you could have actually allocated those tasks in a different way amongst different entities. And so when you're designing the application or your competing environment, then you can have some ability to rearrange how those tasks are distributed between different entities. So that they have different roles. And when you're doing that, you want to think about the other security principles that we're talking about. So the idea of entities and roles is really fundamental in thinking about security and all the rest of the security principles here. So some things you might think about like, okay, we've got second application server. In this case, we're thinking about a very simple kind of cloud architecture where it's just a couple of things. If I have an EC2 instance, let's come out running my application server, what does that need to do? And then I have maybe a database service. And what does it need to do? And those answers to those two things are going to be very different. So one of the things that comes out of this is that when we're thinking about the different roles that an entity has, we want to apply the principle of least privilege, which basically says that we only give the privileges that are necessary for that particular role for that job that it has. So the reason why is because you can imagine that, let's suppose that if there was some kind of attack that there was vulnerability and a resource is compromised. So for example, an attacker gets a hold of a virtual machine, gets read access on a virtual machine. Now, it can do whatever that virtual machine can do. And so you want to limit that as much as possible. So you've got like the two competing requirements, security requirement will like to have that as low as possible, like down to zero if possible. And the, but from a functionality point of view, you would have a certain requirements for what you, as required for that thing to do its job. So what you want to have is going to like draw the line right in the middle of the least privilege. So you give it, you give it the privileges that required for the job for this role and no more. Okay. So that's one of the reasons is that that does protect against those kind of like compromised entity, but it also limits the attack surface. So attack surface that just means like all the different ways that that your entity is exposed to someplace where an attacker could could kind of poke at it or get get get at it. And so if you've got more privileges than in some cases, that will mean a larger attack surface. So like one thing you probably, you can think of a privilege might be the privilege of accepting incoming connections on a certain port. Okay. That doesn't sound like very much of a privilege, but that's like a security thing that you're allowing that thing to happen, right? And if so, let's suppose that if you allow certain things to happen, then the like then incoming certain kind of incoming connection, then that's in a way that an attacker can initiate it and can come into connection to that entity. And maybe there's something there that the attacker can get hold of. And so if that incoming connection isn't necessary, then we can not allow it and that will limit the attack surface. So it's so at least for a glitch, a castle is kind of two ideas. Like if there was a problem, then we can contain it and also limit the attack surface so that we can hopefully avoid problems at the beginning. So as an example here, your database, it's extremely rare that you would want to have your database on the public internet. You almost always want to have something in front, even though there's like, you know, password protected or whatever like that, it just, there's no necessary, it's not necessary for anybody on the public internet to be able to connect to make a connection to your database. Forget about logging in just like even making a connection. There's no almost always nobody has any business doing that. So let's not allow that. We don't have that privilege. Another principle is separation of concerns. And this kind of goes back to this question of understanding these roles. And when you're designing your entities and your roles, then you can then you can apply separation of concerns. So what we want to have is that if you caught a like a group of a bunch of tasks that need to be done, what you want to do is to distribute those tasks into different entities. So that because usually if you have fewer tasks that are required for an entity to do, then it requires fewer privileges. And then you can apply your lease probably the line of where is the lease privilege goes down if you have a smaller entity. So separation of concerns means that you want to make those, make those components kind of as small as practically possible so that you can make the privileges that are required as small as possible. And a particular case where this is kind of really important is when you have like a certain thing that has to get done, but there's different aspects of it. So one example that comes here is like making a, we have some stuff that's associated with a resource like maybe creating a service or configuring a service. But there's also like I have to be able to read and modify the logs for that service. Now you might want to, it's a good idea to separate those two things. Like they're both related to the same thing, but we want to separate them because you, if one, especially with logging, because if one container is messing around and not doing things correctly, then you want to be able to catch that with a log. Right. So those are two kind of different aspects of this task, you know, of, of, of, and demonstrating this service. And so those two different aspects should be handled by different entities so that you can, you can apply at least privilege so that you end those two aspects are separated so that you, you can't create a worse vulnerability by having, by, by having these two different things happen at the same time by an attacker, for example, where they can change the configuration and then hide it from you. A different way of, so that, so that this particular kind of way of slicing that, that, that tasks that it's, that's useful there. A different way of slicing the tasks. So, so that this task might be like, we have logging as a task and configuration, configuration as a task and we're not going to allow those two things, right. A different, the other way of slicing it would be maybe, maybe, per service. So each service has an entity that can modify the logs for it and modify the configuration, but that's not, that's not, that's good. So separation of current concerns, we'd especially want that across different types of activities. So, examples of different types of activities is like, you know, storing data, that is a very different type of task from serving requests from the public internet. And definitely this is what another example where we want to have a separation because if you, you could like serve all what, once something is on the public internet, you know, then maybe it's, it's already vulnerable, but we don't want that to intersect with where we're storing our data, right. The other way of doing it would be, okay, well, we have a bunch of different bits of data and different services. So, we'll combine those together and that's not a very good way of doing it because the, as soon as a server is compromised, then that's also compromised. Whereas if we got it kind of sliced at the other direction, then the networks is a little bit different. So maybe we'll just draw a diagram to here. So maybe we've got some, we've got some servers here, circles are servers, and we've got some, some databases here. So one way of, one way of slicing our data would be, you can hear, here's two tasks. You know, one is, you know, data, one is serving. And then a different way of slicing your data, or if you're just slicing your tasks, might be, you know, each of these things is kind of, for a different kind of data. So maybe this would be, you know, like, I know users and comments are, okay, making things up here, but, you know, there's different ways. So if you slice your kind of your, your, your rolls up like this, well, then as soon as you have, you know, as soon as you have, like, maybe an attack on this from the internet, then that immediately transfers to an attack on their data, whereas you slice it the other direction, well, your data is protected. So when you're thinking about, except for your, of concerns, you should think about it in, in this kind of direction, or in this kind of way of like, separating different types of tasks as well. So, defense separation concerns on these perlige are, are really the, the key to most of the rest of things that are happening. And, and of course, this, this kind of underlies that. And then the other things are kind of like, no, now how should we kind of compose those things together? So one is defense in depth. So this is about, it's kind of like, how would should you, what, once you've got the kind of the basics of, okay, I'm going to have least perlige or something, but you can compose your different, you can compose your different entities in different ways. Especially when you're talking about like groups of entities that like subnets. So how can we kind of use that to make, to make kind of more robust structures? So one way is defense in depth. So the idea is that we're going to create these layered structures where we have multiple things that protect the, what you want. And the more valuable it is the more protections you want on it. So that's one of the reasons why we, we put our data kind of behind our server so that if, if there is an attack on the server, that's not the end of it that we have, that we have another step to go. And one way, you know, that this is using the kind of permission structures is one way of doing it. But you can imagine another way of doing that would be to make use of like networks. So we'll talk about subnets in that later ones with Jake, but you can have like kind of all these, all these servers here on a network and our databases are on a separate network. Right. And then we can put a bit, big firewall in between there. So here it is a layering of things so that this subnet you can think of as kind of like, it's itself an entity, but it kind of contains these entities. And then we have these other things and we're going to create this kind of layers structure so that if a, if you have a attack that's coming from the outside, it will have to go through now, do something and mess up this server, get a hold of this server, and then it has to be able to make a connection through that firewall to this stuff behind. So we have, so that we can't, we've got like a kind of a couple of different places here where we might be able to catch an attack. And then hopefully you would have, again, some kind of like least privilege of being applied here. So there's actually some kind of an additional thing here, maybe a authentication, like you have to have a password. So that there would be actually in this case, you know, like one, two, three, a different, different things that can catch different stuff. They're not all going to catch the same thing. They're different, they're working on different types of things like, you know, authentication is one thing, some kind of network filtering another thing, and having an application here, which provides some kind of buffering between these, between these two things. So each one of those things operates on a, kind of a different, in a different way to prevent that kind of a cost from going through, but now we've got multiple layers. So that's what defense in depth is. So, and having multiple mechanisms, so we have actually different kinds of mechanisms as well. So as an example, there's something called access control lists, which are used basically like firewalls. And there's another thing called security groups. They're also kind of like firewalls, but they work in a different way. And so by having both of them, you can have that kind of that extra, extra layering for the defense in depth. Another thing, kind of idea, kind of a basic idea is that when you have an opportunity to have some security, then you should take it. So sometimes this means that like in, you can set up useful defaults. So as an example, you can like redirect requests. So sometimes somebody tries to connect to your server with HTTP. You can just do a redirect to the, to the secure version. Another one would be that when you create subnets or when you create, say virtual machines, there are, you can't just have like no security group. There's a default security group that virtual machines get added to. And you can configure that default security group to have a very secure default setting so that if you forget to how add a security group, you don't end up with no filtering. You end up with complete filtering so that you have to, if you make a mistake, then the, then that kind of fails in the right, in the correct, in the secure direction. Or when you have a subnet, because similarly, you can have defaults, a network access control there, or a list which has a similar role. So you can have the default in ACL to be like block everything so that if you forget you make a mistake of not, of not, you know, implementing those rules, then you fail in a secure direction. Okay, security by design. So mostly this is everything that we've been talking about, but now thinking about that from a design perspective. Many of these things can be implemented kind of patched on later on, especially like security groups and ACLs. But some things you can't, you can't make that choice later on unless you go back and rebuild something. So when you're designing your app, you should be thinking about how is this going to be made secure. So you can't separate the duties. If you don't have those entities separated out, right? If you separate those entities, if you separate those entities in this way, you know, in the blue way, so that each one of those things that's now a virtual machine or something like that, you have, if you want to implement the, the things other direction, then you have to rebuild that, right? And so you can make things harder for yourself by not thinking about those design aspects of security or anyone. And another thing is like, you have to have, sometimes you have to have the structures built into the system to allow that. Like some things are going to be there. Like if you're using AWS or whatever, then you will have security groups. Those are there. But if you don't have, for example, a fine grain permission structure built into your app or allowing for your user authorization, then you can't do any filtering based on that, right? You can't constrain your user's permissions. If you don't, in that way, if you don't have that mechanism there, so you need to think about that when you're building your application. Think about what through security requirements are going to be. And then those become design requirements. Okay, so these things, hopefully it's clear already that these things all work together. So here's what you have to do is consider at the beginning, when you're designing the system, you have to consider what everything is that needs to get done. So you have to understand what are the different tasks you need to get done. And then you can then create those different identities and roles so that you have the appropriate separation of duties. Right? And then once you have those separation of duties, you can organize those things in these layer structures that gives you the defense and death. And then finally, each entity you can now apply lease privilege. And you've got those opportunities to create lease privilege because you've got these appropriate separation of duties or separation of concerns, different, just the same thing, different name, or Andy have also got those layered structures where you've got those kind of interfaces between the layers, where you can apply some lease privilege. Okay. So there are always trade-offs when it comes to security. It would be great if security wasn't something we had to worry about. And then we could just design stuff to be functional and don't have to worry about that. But because security is something that you have to worry about, you have to make the trade-offs and think about what those trade-offs are going to be. So one is that when you're creating multiple entities, which is great from the point of view of separation of concerns, it does increase your management overhead. Right? And there also can be there can be kind of like overheads that you get from the communication between those because you have to now go over some kind of communication mechanism that'll introduce a little bit of overhead. So those things do kind of reduce the efficiency of your system. And also like if you have tight privileges, if you do have like really struct lease privilege, then if you want to make a change to the system, now you have to change all of those permissions. So that can add, you may add, introduce some friction in changing things. That's not necessarily a bad thing because it forces you to, okay, I'm actually going to go through with this work to do it. Is it worth doing it? Or is there a better way I can do it without having to do that, which would actually probably be better for this from a security point of view. So like sometimes it's actually good, but it does increase that friction there a little bit. And there is just more things to worry about. So it does come with this extra burden. But on the other side of that is, if there is some kind of breach, do you really want to be the next meta bank or something like that, right? So you can use risk management stuff, which we're not talking about here. That's more of a security thing, not a cloud thing specifically. So you can use risk management frameworks to think about how you kind of make those tradeoffs. So it's important to note that it's like making tradeoffs is acceptable. Like sometimes you can say, yeah, we're not going to implement that security feature because it's actually not worth it for the benefit that we're going to get. So sometimes very often people don't even bother with using an ACLs and just use security groups because that's extra work. But it's probably not a good idea to have no filtering at all. There's some trade offs that it's okay to make and there's some trade offs, so it's just like, no, that's just a bad idea. So you have to find out where is that line for your application in the environment that you're operating? Where is that line between, hey, this is an acceptable trade off to make and no, that's too far. So it's a kind of like a more personal example that people might have. Okay, and this is one that people probably don't think about very much, or would maybe might disagree with me about what you, if you want to write down your Facebook password, like actually write it down rather than remembering it or other kind of passwords, your pen for your card or whatever, yeah, write it down because most of the time, the kind of the attack mode that you're looking at or the type of threats that you're looking at, don't involve somebody coming into your house and stealing stuff, and it's tough from you to find your passwords, right? That's just not something that you're generally going to be worried about. So if you want to write it down, it's actually not a big compromise for security. What is it, but what would be a compromise? So this is kind of a hedge against forgetting your password, right? There's different ways that you could kind of hedge against forgetting your password by making it very easy to remember, but that might make it very easy to gas. And this is something that can be taken advantage of by people over the internet. This one can't be taken advantage of over the internet. You have to come to your house. This one, it can be. So this is one where you're definitely making a huge compromise for your security for the sake of convenience. This one, it's maybe a little less convenient, but you're still going to not forget your password, and the security, the security compromise is much better here. So you can use a risk framework to evaluate those trade-offs. And you don't have to go, I think, very hard to find examples. There are big things in the news where people have corners, and there have been bad consequences for that. If you could download the PDF, these are some links to a couple of just articles. And specifically looking at S3 buckets, because this is one of the big ways that people using AWS will expose themselves to threats on the internet because they don't have appropriate controls on their S3 buckets. So very much recommend having a look. And this one's also about S3 buckets and credentials, I think. So have a look at those. So last thing here is that, usually people think security as something that gets in the way of development. It's like, oh, we could work faster if we didn't have to worry about the security stuff forever. But it doesn't necessarily should have to be that way. So if you're doing things well and thinking about them together, then it can actually be a benefit to think about security while you're doing your design and development. So one of the things is that you're going to have to add security at some point. And if you add it later, then it can be harder to implement than if you edit while you're in design. And of course, you're going to have a harder time of doing that of having effective security if you can't make those those, you know, can't go back and make those design choices around separation of concern. For example, so it can be easier overall to make those design choices to consider security during your design. So separation of concerns is what security people call it, but programmers will call it modularity. And this is the same thing. And there's a lot of different ways that we achieve modularity in software development. And you know, this object oriented programming, functional programming is to get it to the one way of doing modularity through multiple different functions. Containers is again another modular thing. And those are that's also driven primarily from a development point of view. So those things which you kind of want anyway for good software design, just from a kind of maintainability and point of view and like, making keeping things, keeping your software structured in a way that you'll be able to actually work on it. Those that modularity gets you separation concerns essentially, right? So you kind of want this anyways. And so, well, it's just this just means that while I'm doing that modularity from a point of view of development, I can think about security. What does this mean for security? So it's not really at the point here is that separation of getting separation of concerns isn't necessarily add very much in terms of workload. These privileged is good from another point of view, which is that sometimes you have things which should pretty shouldn't be accessed. And you know, they're not intended to be accessed. But some people do that anyways. You know, they kind of have these little little things like so a great example would be like having a browser extension that modifies website and gives you some functionality. That's not intended, right? And then when the very what what happens is that when the website changes, then that extension will no longer work, right? Because now they've broken something. It wasn't intended to be a public interface for people to be used. And so they just change it whenever they want. But now it's broken something, right? And so if you have a fleece privilege, that means that people just can't access that stuff, but not supposed to access. And then you won't make use of those things that you're not supposed to make use of. And so an exalt and an analogous thing is something like Java, where you have if you create an object, you can declare the methods as other public or private. And if it's declared as private, then other things can't use it. And that's good because it means that if you later on change that what that private function does, then you don't break everybody else's code, right? So that's this isn't again, this kind of leaves this privilege type of thing is it's or ways of of making use of that are built into programming languages. Other other things like Python don't have that. They have other mechanisms for helping it with that, but they don't have that kind of private or for syspilvic functions. But another thing that's very useful is like there's and this comes up not just with security, but other things like testing, where you have is having a second look at your application, whether that be from a functionality point of view or from a structure point of view, having a different way of thinking about that same thing can expose problems that you wouldn't have thought of otherwise. So this is why we have bucks, right? Because you're with the person who's developing, you know, has you know, they have a certain way that they're thinking about this app being used, and then you have the you know, a tester who comes along and does something that you completely didn't anticipate. And they're like, oh yes, well, here's the problem. And it's having a second look at the same thing that exposing the problem. So you wouldn't otherwise notice. And security is good for this because like vulnerabilities in applications are very often bugs. They're bugs that haven't been exposed in other ways, but now what's as exposed from this security point of view, and then you now you notice a bug. So like one way of finding bugs in software is where you just kind of give random inputs and you try to crash the app. If you crash the app, you found a bug, but you've also potentially found a place where you can a way that you can inject code or get the app to behave in a way that's not expected. So having that that kind of way of thinking about things from a security point of view can help you to find bugs in your code. Okay. So that's that's not a good design. And at this point, we're going to have Jake come in and do a little bit of stuff about networking in the cloud. And then we'll you'll hear back from me again about some more stuff related to security.